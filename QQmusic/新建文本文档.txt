1、介绍JavaScript的基本数据类型？
           基本数据类型：Number、String、Boolean、Null、Undefined
           object是JavaScript中所有对象的父对象
           数据封装类对象：object、Array、Boolean、Number、String
           其它对象：Function、Arguments、Math、Date、Error、RegExp
           其它数据类型：Symbol
2、浅谈JavaScript中变量和函数声明的提升？
          在JavaScript中变量和函数的声明会提升到最顶部执行
          函数的提升高于变量的提升
          函数内部如果用var声明了相同名称的外部变量，函数将不会向上寻找
          匿名函数不会提升
          不同<script>块中的函数互不影响
3、什么是闭包，闭包有什么特性？
          闭包就是能够读取其它函数内部变量的函数
          闭包是指有权访问另一个函数作用域中变量的函数，创建闭包最常见的方式就是在一个函数内部创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包可以突破作用域链
          闭包的特性
          函数内再嵌套函数
          内部函数可以引用外部的参数或变量
          参数和变量不会被垃圾回收机制回收
4、说说对闭包的理解和闭包的作用
         使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，增大内存使用量，使用不当很容易造成内存泄漏。在JS中，函数即闭包，只有函数         才会产生作用域的概念
         闭包的最大用处有2个，一个是可以读取函数内部的变量，另一个就是可以让这些变量始终保持在内存中
         闭包的另一个用处是封装对象的私有属性和方法
         好处：能够实现封装和缓存
         坏处：就是消耗内存、不正当使用会造成内存溢出的问题
         使用闭包的注意点
         由于闭包会使得函数中的变量都保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏。
         解决方法是，在退出函数之前，将不使用的局部变量全部删除。
5、说说对This对象的理解
        this总是指向函数的直接调用者，而非间接调用者
        如果有new关键字，this指向new出来的那个对象
        在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象window
6、说说对事件模型的理解
        W3C中定义时间的发生精力三个阶段
       捕获阶段、目标阶段、冒泡阶段
       冒泡型事件：当你使用事件冒泡时，子元素先触发，父元素后触发
       捕获型事件：当你使用事件捕获时，父元素先触发，子元素后触发
       DOM事件流：同时支持两种事件模型，捕获型事件和冒泡型事件
       阻止冒泡：在W3C中，使用stopPropagation()方法；在IE下设置cancelBubble = true
       阻止捕获：阻止事件的默认行为，例如click - <a>后的跳转。在W3C中，使用preventDefault()方法，在IE下设置window.event.returnValue = false
7、new 操作符具体干了什么？
      创建一个空对象，并且this变量引用该对象，同时还继承了该函数的原型
      属性和方法被加入到this引用的对象中
      新创建的对象由this所引用，并且最后隐式的返回this
      1. 创建一个空的简单 JavaScript 对象（即 {}）；
      2. 为步骤 1 新创建的对象添加属性 __proto__，将该属性链接至构造函数的原型对象；
      3. 将步骤 1 新创建的对象作为 this 的上下文；
      4. 如果该函数没有返回对象，则返回 this。(new了之后必须返回对象{})
8、说说栈和堆的理解，以及它们的区别？
      栈内存：栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义      ，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命后期都很短
      堆内存：存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆内存中，堆内存的都是放的实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据         消失，这个实体也不会消失，还可以使用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，有         垃圾回收机制不定时的收取

      栈和堆的区别：
      栈内存存储的是局部变量，而堆内存存储的是实体
      栈内存更新速度要快于堆内存，因为局部变量的生命周期都很短
      栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收
9、JS数组和对象的遍历方式，以及几种方式的比较
      for in 循环、for 循环、forEach 循环
      这里的forEach回调中两个参数分别为：value , index
      forEach无法遍历对象
      IE不支持该方法；FireFox和Chrome支持
      forEach无法使用break ，continue跳出循环，且使用return是跳过本次循环
      for-in 需要分析出array的每个属性，这个操作性能开销很大。用在key已知的数组上是不划算的。所以尽量不要用for-in，除非你不清楚要处理哪些属性，例如JSON对象这样的情况
      for循环每进行一次，就要检查一下数组长度。读取属性（数组长度）要比读局部变量慢，尤其是当array里存放的都是DOM元素，因为每次读取都会扫描一遍页面上的选择器相关元素，速度会大大      降低
10、map和forEach的区别
      forEach方法，是最基本的方法，就是遍历与循环，默认有3个参数：分别是遍历的数组内容item、数组索引index、当前遍历的数组Array
      map方法，基本用法与forEach一致，但不同的是，它会返回一个新的数组，所以callback需要有return值，如果没有，会返回undefined
